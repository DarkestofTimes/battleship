{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,gBAAgB;AAC1B,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,sBAAsB,eAAe;AACrC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B;AACA,QAAQ;AACR;AACA,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B,YAAY,gBAAgB;AAC5B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,iCAAiC,MAAM;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACrcsD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C,8BAA8B,sCAAsC;AACpE;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE,aAAa,EAAE;AACzE;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;UCxPA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNsD;AACb;AACzC;AACA,cAAc,+CAAK;AACnB,mBAAmB,sDAAU;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA","sources":["webpack://battleship/./src/game.js","webpack://battleship/./src/render.js","webpack://battleship/webpack/bootstrap","webpack://battleship/webpack/runtime/define property getters","webpack://battleship/webpack/runtime/hasOwnProperty shorthand","webpack://battleship/webpack/runtime/make namespace object","webpack://battleship/./src/index.js"],"sourcesContent":["export const Ship = (num, bool) => {\r\n  return {\r\n    size: num,\r\n    hits: 0,\r\n    isSunk: false,\r\n    xAxis: bool,\r\n    x: [],\r\n    y: [],\r\n    wasHit() {\r\n      this.hits++;\r\n    },\r\n    wasSunk() {\r\n      if (this.hits >= this.size) {\r\n        this.isSunk = true;\r\n        return this.isSunk;\r\n      }\r\n      return this.isSunk;\r\n    },\r\n  };\r\n};\r\n\r\nexport const Board = () => {\r\n  return {\r\n    visited: [],\r\n    occupied: [],\r\n    sunken: [],\r\n    hits: [],\r\n    createGrid() {\r\n      const axis = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n      const grid = axis.map((x) => axis.map((y) => [x, y])).flat();\r\n      return grid;\r\n    },\r\n    isOver() {\r\n      if (this.sunken.length >= this.occupied.length) {\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    canBePlaced(x, y, size, axis, array) {\r\n      const directions = [\r\n        { dx: -1, dy: 0 },\r\n        { dx: 1, dy: 0 },\r\n        { dx: 0, dy: -1 },\r\n        { dx: 0, dy: 1 },\r\n        { dx: -1, dy: -1 },\r\n        { dx: 1, dy: -1 },\r\n        { dx: -1, dy: 1 },\r\n        { dx: 1, dy: 1 },\r\n      ];\r\n      const coords = [];\r\n      if (x < 0 || y < 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      coords.push({ cx: [x], cy: [y] });\r\n      for (let i = 1; i <= size - 1; i++) {\r\n        if (axis) {\r\n          coords[0].cx.push(x + i);\r\n        } else {\r\n          coords[0].cy.push(y + i);\r\n        }\r\n      }\r\n\r\n      const mappedDirections = coords[0].cx.flatMap((cx) =>\r\n        coords[0].cy.flatMap((cy) =>\r\n          directions.map((direction) => ({\r\n            x: cx + direction.dx,\r\n            y: cy + direction.dy,\r\n          }))\r\n        )\r\n      );\r\n\r\n      const matchingCoords = array.filter((obj) =>\r\n        mappedDirections.some(\r\n          (coord) => obj.x.includes(coord.x) && obj.y.includes(coord.y)\r\n        )\r\n      );\r\n\r\n      if (axis && x + size - 1 > 9 && x >= 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      if (!axis && y + size - 1 > 9 && y >= 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      if (matchingCoords.length !== 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      coords.can = true;\r\n      return coords;\r\n    },\r\n    placeShip(x, y, size, axis) {\r\n      //place\r\n      if (this.canBePlaced(x, y, size, axis, this.occupied).can) {\r\n        const newShip = Ship(size, axis);\r\n        if (newShip.xAxis) {\r\n          newShip.y.push(y);\r\n          newShip.x.push(x);\r\n          for (let i = 1; i <= size - 1; i++) {\r\n            newShip.x.push(x + i);\r\n          }\r\n        } else {\r\n          newShip.x.push(x);\r\n          newShip.y.push(y);\r\n          for (let i = 1; i <= size - 1; i++) {\r\n            newShip.y.push(y + i);\r\n          }\r\n        }\r\n        this.occupied.push(newShip);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n    fleetIsReady(array) {\r\n      if (array.length === 6) {\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    markAdjacent(coordsObject, sunk) {\r\n      let directions;\r\n      if (!sunk) {\r\n        directions = [\r\n          { dx: -1, dy: -1 },\r\n          { dx: -1, dy: 1 },\r\n          { dx: 1, dy: -1 },\r\n          { dx: 1, dy: 1 },\r\n        ];\r\n      } else {\r\n        directions = [\r\n          { dx: -1, dy: 0 },\r\n          { dx: 1, dy: 0 },\r\n          { dx: 0, dy: -1 },\r\n          { dx: 0, dy: 1 },\r\n          { dx: -1, dy: -1 },\r\n          { dx: 1, dy: -1 },\r\n          { dx: -1, dy: 1 },\r\n          { dx: 1, dy: 1 },\r\n        ];\r\n      }\r\n\r\n      const mappedCoords = coordsObject.x.flatMap((cx) =>\r\n        coordsObject.y.flatMap((cy) =>\r\n          directions.map((direction) => ({\r\n            x: cx + direction.dx,\r\n            y: cy + direction.dy,\r\n          }))\r\n        )\r\n      );\r\n\r\n      return mappedCoords.map(({ x, y }) => [x, y]);\r\n    },\r\n\r\n    IncomingAttack(x, y) {\r\n      // attack\r\n      if (this.visited.some((pair) => pair[0] === x && pair[1] === y)) {\r\n        return false;\r\n      }\r\n      this.visited.push([x, y]);\r\n\r\n      const theRightShip = this.occupied.filter(\r\n        (obj) => obj.x.includes(x) && obj.y.includes(y)\r\n      );\r\n      if (theRightShip[0]) {\r\n        theRightShip[0].wasHit();\r\n        this.hits.push([x, y]);\r\n        if (theRightShip[0].wasSunk()) {\r\n          let marks = this.markAdjacent(\r\n            {\r\n              x: theRightShip[0].x,\r\n              y: theRightShip[0].y,\r\n            },\r\n            true\r\n          );\r\n          marks.forEach((mark) => {\r\n            if (\r\n              !this.visited.some(\r\n                (pair) => pair[0] === mark[0] && pair[1] === mark[1]\r\n              ) &&\r\n              mark[0] >= 0 &&\r\n              mark[0] <= 9 &&\r\n              mark[1] >= 0 &&\r\n              mark[1] <= 9\r\n            ) {\r\n              this.visited.push(mark);\r\n            }\r\n          });\r\n          this.sunken.push(theRightShip[0]);\r\n        }\r\n        let marks = this.markAdjacent({ x: [x], y: [y] }, false);\r\n\r\n        marks.forEach((mark) => {\r\n          if (\r\n            !this.visited.some(\r\n              (pair) => pair[0] === mark[0] && pair[1] === mark[1]\r\n            ) &&\r\n            mark[0] >= 0 &&\r\n            mark[0] <= 9 &&\r\n            mark[1] >= 0 &&\r\n            mark[1] <= 9\r\n          ) {\r\n            this.visited.push(mark);\r\n          }\r\n        });\r\n        return theRightShip[0];\r\n      }\r\n      return false;\r\n    },\r\n    reportLost() {\r\n      if (this.sunken.length !== 0) {\r\n        const lostShip = this.sunken.pop();\r\n        return lostShip;\r\n      }\r\n      return false;\r\n    },\r\n  };\r\n};\r\n\r\nexport const Player = (type) => {\r\n  return {\r\n    type: type,\r\n    nextTarget: [],\r\n    hits: [],\r\n    possibleTargets(coords) {\r\n      let directions = [\r\n        { dx: -1, dy: 0 },\r\n        { dx: 1, dy: 0 },\r\n        { dx: 0, dy: -1 },\r\n        { dx: 0, dy: 1 },\r\n      ];\r\n      const mappedCoords = directions.map((direction) => ({\r\n        x: coords.x + direction.dx,\r\n        y: coords.y + direction.dy,\r\n      }));\r\n      const validCoords = mappedCoords.filter((obj) => {\r\n        return obj.x <= 9 && obj.x >= 0 && obj.y <= 9 && obj.y >= 0;\r\n      });\r\n\r\n      return validCoords;\r\n    },\r\n    excludeCells(coord, board) {\r\n      const dirs = [];\r\n      const map = (coord, board) => {\r\n        const temp = [];\r\n        temp.push({ x: coord.x + 1, y: coord.y });\r\n        temp.push({ x: coord.x, y: coord.y + 1 });\r\n        temp.push({ x: coord.x - 1, y: coord.y });\r\n        temp.push({ x: coord.x, y: coord.y - 1 });\r\n\r\n        const filtered = temp.filter((obj) => {\r\n          return obj.x <= 9 && obj.x >= 0 && obj.y <= 9 && obj.y >= 0;\r\n        });\r\n        const notVisited = filtered.filter((element) => {\r\n          return !board.visited.some(\r\n            (pair) => pair[0] === element.x && pair[1] === element.y\r\n          );\r\n        });\r\n        return notVisited;\r\n      };\r\n      const mapped = map(coord, board);\r\n\r\n      if (mapped.length == 0) {\r\n        dirs.push([coord.x, coord.y]);\r\n      } else {\r\n        mapped.forEach((item) => {\r\n          if (map(item, board).length >= 3) {\r\n            dirs.push([item.x, item.y]);\r\n          }\r\n        });\r\n      }\r\n\r\n      return dirs;\r\n    },\r\n    calcTargetCoords(board) {\r\n      const grid = board.createGrid();\r\n      const filteredCoords = grid.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element[0] && pair[1] === element[1]\r\n        );\r\n      });\r\n      const random = Math.floor(Math.random() * filteredCoords.length);\r\n      const coords = filteredCoords[random];\r\n      return { x: coords[0], y: coords[1] };\r\n    },\r\n    searchPattern(board) {\r\n      const tempX = [];\r\n      const tempY = [];\r\n      const arrayOfArrays = [];\r\n      const grid = board.createGrid();\r\n      const filteredCoords = grid.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element[0] && pair[1] === element[1]\r\n        );\r\n      });\r\n      const alive = board.occupied.filter((ship) => {\r\n        return ship.isSunk === false;\r\n      });\r\n      const biggest = alive.sort((a, b) => a.size - b.size)[0].size;\r\n\r\n      const coordsByY = [...filteredCoords].sort((a, b) => a[1] - b[1]);\r\n\r\n      function processArray(arr, tempArr, arrayOfArrays) {\r\n        for (let i = 0; i < arr.length; i++) {\r\n          const current = arr[i];\r\n          const previous = i > 0 ? arr[i - 1] : arr[i];\r\n          const next = i < arr.length - 1 ? arr[i + 1] : arr[i];\r\n\r\n          if (current[1] === previous[1] && current[0] === previous[0] + 1) {\r\n            tempArr.push([current[0], current[1]]);\r\n          }\r\n          if (\r\n            current[0] !== next[0] - 1 ||\r\n            (current[1] !== next[1] &&\r\n              current[1] === previous[1] &&\r\n              current[0] === previous[0] + 1)\r\n          ) {\r\n            arrayOfArrays.push([...tempArr]);\r\n            tempArr.length = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      processArray(coordsByY, tempY, arrayOfArrays);\r\n      processArray(filteredCoords, tempX, arrayOfArrays);\r\n\r\n      const biggerThanBiggest = arrayOfArrays.filter(\r\n        (array) => array.length >= biggest\r\n      );\r\n\r\n      const targetArrays = biggerThanBiggest.sort(\r\n        (a, b) => b.length - a.length\r\n      );\r\n      if (targetArrays.length !== 0) {\r\n        const random = Math.floor(Math.random() * targetArrays.length);\r\n        const targetCoords =\r\n          biggest < 4\r\n            ? targetArrays[random][Math.floor(targetArrays[random].length / 2)]\r\n            : targetArrays[0][Math.floor(targetArrays[0].length / 2)];\r\n        return { x: targetCoords[0], y: targetCoords[1] };\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    commitAttack(board, input = this.searchPattern(board)) {\r\n      //ATTACK\r\n      this.nextTarget = this.nextTarget.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element.x && pair[1] === element.y\r\n        );\r\n      });\r\n\r\n      let coords = input;\r\n\r\n      const excluded = this.excludeCells(coords, board);\r\n      const excludedAdnVisited = [...board.visited, ...excluded];\r\n      while (\r\n        excludedAdnVisited.some(\r\n          (pair) => pair[0] === coords.x && pair[1] === coords.y\r\n        )\r\n      ) {\r\n        coords = this.calcTargetCoords(board);\r\n      }\r\n\r\n      if (this.nextTarget.length !== 0) {\r\n        coords = this.nextTarget.splice(\r\n          Math.floor(Math.random() * this.nextTarget.length),\r\n          1\r\n        )[0];\r\n      }\r\n\r\n      const attack = board.IncomingAttack(coords.x, coords.y);\r\n      if (attack) {\r\n        const nextCoords = this.possibleTargets(coords);\r\n        nextCoords.forEach((coord) => this.nextTarget.push({ ...coord }));\r\n        this.hits.push(coords);\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    createFleet(board) {\r\n      const size = [4, 3, 3, 2, 2, 2];\r\n      while (board.occupied.length < 6) {\r\n        const coords = this.calcTargetCoords(board);\r\n        const axis = Math.random() < 0.5 ? false : true;\r\n        const place = board.placeShip(coords.x, coords.y, size[0], axis);\r\n        if (place) {\r\n          size.shift();\r\n        }\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\nexport const Game = () => {\r\n  const computer = {\r\n    player: Player(\"Computer\"),\r\n    board: Board(),\r\n  };\r\n  const human = {\r\n    player: Player(\"Human\"),\r\n    board: Board(),\r\n  };\r\n\r\n  return {\r\n    current: human.player.type,\r\n    over: false,\r\n    computer: computer,\r\n    human: human,\r\n    newGame(input) {\r\n      computer.player.createFleet(computer.board);\r\n      !input\r\n        ? human.player.createFleet(human.board)\r\n        : input.forEach((item) => human.board.placeShip(item));\r\n    },\r\n    declareWinner() {\r\n      if (human.board.isOver()) {\r\n        this.over = true;\r\n        return computer.player.type;\r\n      } else if (computer.board.isOver()) {\r\n        this.over = true;\r\n        return human.player.type;\r\n      }\r\n      return false;\r\n    },\r\n    turn(input) {\r\n      if (!this.over) {\r\n        if (this.current === \"Computer\") {\r\n          computer.player.commitAttack(human.board);\r\n          this.current = \"Human\";\r\n          return true;\r\n        }\r\n        if (this.current === \"Human\") {\r\n          input\r\n            ? computer.board.IncomingAttack(input[0], input[1])\r\n            : human.player.commitAttack(computer.board);\r\n          this.current = \"Computer\";\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n    },\r\n    reportCurrentPlayer() {\r\n      if (this.current === \"Human\") {\r\n        return this.current;\r\n      } else {\r\n        return this.current;\r\n      }\r\n    },\r\n  };\r\n};\r\n","import { Ship, Board, Player, Game } from \"./game.js\";\r\n\r\nexport const RenderGame = () => {\r\n  return {\r\n    shipsToPlace: [],\r\n    shipsOnGrid: [],\r\n    renderGrid(board) {\r\n      const grids = document.querySelectorAll(\".grid\");\r\n      const cells = board.createGrid();\r\n      grids.forEach((grid) => {\r\n        cells.forEach((cell) => {\r\n          const newCell = document.createElement(\"div\");\r\n          newCell.classList.add(\"cell\");\r\n          newCell.setAttribute(\"data-x\", cell[1]);\r\n          newCell.setAttribute(\"data-y\", cell[0]);\r\n          grid.appendChild(newCell);\r\n        });\r\n      });\r\n    },\r\n    populateGrid(draggedOffset, ev, board) {\r\n      const canBe = this.checkIfCanBePlaced(draggedOffset, ev, board);\r\n      if (canBe) {\r\n        this.shipsOnGrid.push(canBe);\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    renderShips(array, grid) {\r\n      array.forEach((item) => {\r\n        const gridArray = Array.from(grid.children);\r\n        const cell = gridArray.find(\r\n          (child) =>\r\n            child.getAttribute(\"data-x\") == item.x[0] &&\r\n            child.getAttribute(\"data-y\") == item.y[0]\r\n        );\r\n\r\n        const targetRect = cell.getBoundingClientRect();\r\n        const ship = document.createElement(\"div\");\r\n        ship.classList.add(`ship${item.size}`);\r\n        ship.classList.add(`${item.axis ? \"horizontal\" : \"vertical\"}`);\r\n        ship.style.left = targetRect.left + \"px\";\r\n        ship.style.top = targetRect.top + \"px\";\r\n        grid.appendChild(ship);\r\n      });\r\n    },\r\n    flipShip() {\r\n      const ships = this.shipsToPlace;\r\n      ships.forEach((ship) => {\r\n        ship.addEventListener(\"click\", (ev) => {\r\n          if (ev.target.style.transform == \"rotate(90deg)\") {\r\n            ev.target.setAttribute(\"data-axis\", \"true\");\r\n            ev.target.style.transform = \"none\";\r\n          } else {\r\n            ev.target.setAttribute(\"data-axis\", \"false\");\r\n            ev.target.style.transform = \"rotate(90deg)\";\r\n          }\r\n        });\r\n      });\r\n    },\r\n    checkIfCanBePlaced(draggedOffset, ev, board) {\r\n      const axis = draggedOffset.axis == \"true\" ? true : false;\r\n      const offsetX = axis\r\n        ? ev.target.getAttribute(\"data-x\") - draggedOffset.offset + 1\r\n        : +ev.target.getAttribute(\"data-x\");\r\n      const offsetY = axis\r\n        ? +ev.target.getAttribute(\"data-y\")\r\n        : ev.target.getAttribute(\"data-y\") - draggedOffset.offset + 1;\r\n      const canBe = board.canBePlaced(\r\n        offsetX,\r\n        offsetY,\r\n        draggedOffset.size,\r\n        axis,\r\n        this.shipsOnGrid\r\n      );\r\n      if (canBe.can) {\r\n        return {\r\n          x: canBe[0].cx,\r\n          y: canBe[0].cy,\r\n          size: draggedOffset.size,\r\n          axis: axis,\r\n        };\r\n      }\r\n      return false;\r\n    },\r\n    createShipsToPlace() {\r\n      const sizes = [4, 3, 3, 2, 2, 2];\r\n\r\n      while (this.shipsToPlace.length < 6) {\r\n        const ship = document.createElement(\"div\");\r\n        const size = sizes.shift();\r\n        ship.setAttribute(\"data-size\", size);\r\n        ship.setAttribute(\"data-axis\", true);\r\n        ship.classList.add(\"shipCreate\", `ship${size}`);\r\n        ship.setAttribute(\"draggable\", true);\r\n        this.shipsToPlace.push(ship);\r\n      }\r\n    },\r\n    giveShipToPlace(isTrue) {\r\n      const container = document.querySelector(\r\n        \".fleetCreationScreen .shipsContainer\"\r\n      );\r\n      const count = document.querySelector(\r\n        \".fleetCreationScreen .shipContainerCount\"\r\n      );\r\n      count.textContent = this.shipsToPlace.length;\r\n      container.appendChild(this.shipsToPlace[0]);\r\n      if (isTrue) {\r\n        container.removeChild(container.firstChild);\r\n        this.shipsToPlace.shift();\r\n        count.textContent = this.shipsToPlace.length;\r\n        if (this.shipsToPlace.length !== 0) {\r\n          container.appendChild(this.shipsToPlace[0]);\r\n        }\r\n      }\r\n    },\r\n\r\n    highlightCells(draggedOffset, ev, board) {\r\n      const canBe = this.checkIfCanBePlaced(draggedOffset, ev, board);\r\n      const cells = [];\r\n      const x = +ev.target.getAttribute(\"data-x\");\r\n      const y = +ev.target.getAttribute(\"data-y\");\r\n      const offsetBehind = draggedOffset.size - draggedOffset.offset;\r\n      const axis = draggedOffset.axis == \"true\" ? true : false;\r\n      cells.push(ev.target);\r\n\r\n      const addCellIfValid = (cells, x, y) => {\r\n        const cell = document.querySelector(`[data-x='${x}'][data-y='${y}']`);\r\n        if (cell) {\r\n          cells.push(cell);\r\n        }\r\n      };\r\n      for (let i = 0; i <= draggedOffset.offset - 1; i++) {\r\n        if (axis) {\r\n          addCellIfValid(cells, x - i, y);\r\n        } else {\r\n          addCellIfValid(cells, x, y - i);\r\n        }\r\n      }\r\n      for (let i = 0; i <= offsetBehind; i++) {\r\n        if (axis) {\r\n          addCellIfValid(cells, x + i, y);\r\n        } else {\r\n          addCellIfValid(cells, x, y + i);\r\n        }\r\n      }\r\n\r\n      if (canBe) {\r\n        cells.forEach((cell) => {\r\n          if (cell.classList.contains(\"cellCan\")) {\r\n            cell.classList.remove(\"cellCan\");\r\n          } else {\r\n            cell.classList.add(\"cellCan\");\r\n          }\r\n        });\r\n      } else {\r\n        cells.forEach((cell) => {\r\n          if (cell.classList.contains(\"cellCannot\")) {\r\n            cell.classList.remove(\"cellCannot\");\r\n          } else {\r\n            cell.classList.add(\"cellCannot\");\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    dragElement(board) {\r\n      const ships = this.shipsToPlace;\r\n      const grid = document.querySelector(\".fleetCreationScreen .grid\");\r\n      let draggedOffset;\r\n\r\n      ships.forEach((ship) => {\r\n        ship.addEventListener(\"dragstart\", (ev) => {\r\n          draggedOffset = calculateOffset(ship, ev);\r\n          if (draggedOffset.axis == \"false\") {\r\n            this.rotateDraggedGhostImg(ev);\r\n          }\r\n        });\r\n      });\r\n\r\n      grid.addEventListener(\"dragover\", (ev) => {\r\n        ev.preventDefault();\r\n      });\r\n\r\n      grid.addEventListener(\"dragenter\", (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n        }\r\n      });\r\n\r\n      grid.addEventListener(\"dragleave\", (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n        }\r\n      });\r\n\r\n      grid.addEventListener(\"drop\", (ev) => {\r\n        ev.preventDefault();\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n          const pushShip = this.populateGrid(draggedOffset, ev, board);\r\n          const grid = document.querySelector(\".grid\");\r\n          this.renderShips(this.shipsOnGrid, grid);\r\n          this.giveShipToPlace(pushShip);\r\n        }\r\n      });\r\n\r\n      const calculateOffset = (element, ev) => {\r\n        const rectEl = element.getBoundingClientRect();\r\n        const axis = element.getAttribute(\"data-axis\") == \"true\" ? true : false;\r\n        const cursor = axis ? ev.clientX : ev.clientY;\r\n        let startingPoint = axis ? rectEl.x : rectEl.y;\r\n        const singleCell = axis\r\n          ? rectEl.width / element.getAttribute(\"data-size\")\r\n          : rectEl.height / element.getAttribute(\"data-size\");\r\n        let i = 1;\r\n        while (startingPoint + singleCell < cursor) {\r\n          startingPoint += singleCell;\r\n          i++;\r\n        }\r\n        return {\r\n          offset: i,\r\n          size: +element.getAttribute(\"data-size\"),\r\n          axis: element.getAttribute(\"data-axis\"),\r\n        };\r\n      };\r\n    },\r\n    rotateDraggedGhostImg(ev) {\r\n      const ghost = document.createElement(\"div\");\r\n      if (ev.target.children.length !== 0) {\r\n        console.log(ev.target.children);\r\n        ev.target.removeChild(ev.target.firstChild);\r\n      }\r\n      ghost.style.position = \"absolute\";\r\n      ghost.style.transform = \"rotate(90deg)\";\r\n      ghost.style.pointerEvents = \"none\";\r\n\r\n      const inner = ev.target.cloneNode(true);\r\n      inner.style.pointerEvents = \"none\";\r\n      ghost.appendChild(inner);\r\n\r\n      const rect = ev.target.getBoundingClientRect();\r\n      const x = ev.clientX - rect.left + rect.height / 2.8;\r\n      const y = ev.clientY - rect.top;\r\n\r\n      ev.target.appendChild(ghost);\r\n      ev.dataTransfer.setDragImage(ghost, x, y);\r\n    },\r\n  };\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Ship, Board, Player, Game } from \"./game.js\";\r\nimport { RenderGame } from \"./render.js\";\r\n\r\nconst board = Board();\r\nconst renderGame = RenderGame();\r\nrenderGame.renderGrid(board); //add event listener to trigger rerendering on screen resize\r\nrenderGame.createShipsToPlace();\r\nrenderGame.dragElement(board);\r\n\r\nrenderGame.giveShipToPlace();\r\nrenderGame.flipShip();\r\n"],"names":[],"sourceRoot":""}