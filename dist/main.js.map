{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,gBAAgB;AAC1B,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,sBAAsB,eAAe;AACrC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B;AACA,QAAQ;AACR;AACA,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B,YAAY,gBAAgB;AAC5B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,iCAAiC,MAAM;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC3esD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C,8BAA8B,sCAAsC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,yBAAyB;AACrI;AACA,QAAQ;AACR,0EAA0E,yBAAyB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE,aAAa,EAAE;AACzE;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,8DAA8D,KAAK;AACnE,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,oEAAoE,KAAK;AACzE,wCAAwC,WAAW;AACnD,KAAK;AACL;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA,2CAA2C,gCAAgC,IAAI,iCAAiC;AAChH,yCAAyC,mCAAmC,IAAI,oCAAoC;AACpH,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;UC5nBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNsD;AACb;AACzC;AACA,aAAa,8CAAI;AACjB,mBAAmB,sDAAU;AAC7B","sources":["webpack://battleship/./src/game.js","webpack://battleship/./src/render.js","webpack://battleship/webpack/bootstrap","webpack://battleship/webpack/runtime/define property getters","webpack://battleship/webpack/runtime/hasOwnProperty shorthand","webpack://battleship/webpack/runtime/make namespace object","webpack://battleship/./src/index.js"],"sourcesContent":["export const Ship = (num, bool) => {\r\n  return {\r\n    size: num,\r\n    hits: 0,\r\n    isSunk: false,\r\n    axis: bool,\r\n    x: [],\r\n    y: [],\r\n    wasHit() {\r\n      this.hits++;\r\n    },\r\n    wasSunk() {\r\n      if (this.hits >= this.size) {\r\n        this.isSunk = true;\r\n        return this.isSunk;\r\n      }\r\n      return this.isSunk;\r\n    },\r\n  };\r\n};\r\n\r\nexport const Board = () => {\r\n  return {\r\n    visited: [],\r\n    occupied: [],\r\n    sunken: [],\r\n    attacks: [],\r\n    hits: [],\r\n    createGrid() {\r\n      const axis = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n      const grid = axis.map((x) => axis.map((y) => [x, y])).flat();\r\n      return grid;\r\n    },\r\n    isOver() {\r\n      if (\r\n        this.sunken.length >= this.occupied.length &&\r\n        this.occupied.length !== 0\r\n      ) {\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    canBePlaced(x, y, size, axis, array) {\r\n      const directions = [\r\n        { dx: -1, dy: 0 },\r\n        { dx: 1, dy: 0 },\r\n        { dx: 0, dy: -1 },\r\n        { dx: 0, dy: 1 },\r\n        { dx: -1, dy: -1 },\r\n        { dx: 1, dy: -1 },\r\n        { dx: -1, dy: 1 },\r\n        { dx: 1, dy: 1 },\r\n      ];\r\n      const coords = [];\r\n      if (x < 0 || y < 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      coords.push({ cx: [x], cy: [y] });\r\n      for (let i = 1; i <= size - 1; i++) {\r\n        if (axis) {\r\n          coords[0].cx.push(x + i);\r\n        } else {\r\n          coords[0].cy.push(y + i);\r\n        }\r\n      }\r\n\r\n      const mappedDirections = coords[0].cx.flatMap((cx) =>\r\n        coords[0].cy.flatMap((cy) =>\r\n          directions.map((direction) => ({\r\n            x: cx + direction.dx,\r\n            y: cy + direction.dy,\r\n          }))\r\n        )\r\n      );\r\n\r\n      const matchingCoords = array.filter((obj) =>\r\n        mappedDirections.some(\r\n          (coord) => obj.x.includes(coord.x) && obj.y.includes(coord.y)\r\n        )\r\n      );\r\n\r\n      if (axis && x + size - 1 > 9 && x >= 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      if (!axis && y + size - 1 > 9 && y >= 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      if (matchingCoords.length !== 0) {\r\n        coords.can = false;\r\n        return coords;\r\n      }\r\n      coords.can = true;\r\n      return coords;\r\n    },\r\n    placeShip(x, y, size, axis) {\r\n      //place\r\n      if (this.canBePlaced(x, y, size, axis, this.occupied).can) {\r\n        const newShip = Ship(size, axis);\r\n        if (newShip.axis) {\r\n          newShip.y.push(y);\r\n          newShip.x.push(x);\r\n          for (let i = 1; i <= size - 1; i++) {\r\n            newShip.x.push(x + i);\r\n          }\r\n        } else {\r\n          newShip.x.push(x);\r\n          newShip.y.push(y);\r\n          for (let i = 1; i <= size - 1; i++) {\r\n            newShip.y.push(y + i);\r\n          }\r\n        }\r\n        this.occupied.push(newShip);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    markAdjacent(coordsObject, sunk) {\r\n      let directions;\r\n      if (!sunk) {\r\n        directions = [\r\n          { dx: -1, dy: -1 },\r\n          { dx: -1, dy: 1 },\r\n          { dx: 1, dy: -1 },\r\n          { dx: 1, dy: 1 },\r\n        ];\r\n      } else {\r\n        directions = [\r\n          { dx: -1, dy: 0 },\r\n          { dx: 1, dy: 0 },\r\n          { dx: 0, dy: -1 },\r\n          { dx: 0, dy: 1 },\r\n          { dx: -1, dy: -1 },\r\n          { dx: 1, dy: -1 },\r\n          { dx: -1, dy: 1 },\r\n          { dx: 1, dy: 1 },\r\n        ];\r\n      }\r\n\r\n      const mappedCoords = coordsObject.x.flatMap((cx) =>\r\n        coordsObject.y.flatMap((cy) =>\r\n          directions.map((direction) => ({\r\n            x: cx + direction.dx,\r\n            y: cy + direction.dy,\r\n          }))\r\n        )\r\n      );\r\n\r\n      return mappedCoords.map(({ x, y }) => [x, y]);\r\n    },\r\n    checkCoords(coord) {\r\n      if (\r\n        this.visited.some(\r\n          (pair) => pair[0] === coord[0] && pair[1] === coord[1]\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    IncomingAttack(x, y) {\r\n      // attack\r\n\r\n      this.visited.push([x, y]);\r\n      this.attacks.push([x, y]);\r\n\r\n      const theRightShip = this.occupied.filter(\r\n        (obj) => obj.x.includes(x) && obj.y.includes(y)\r\n      );\r\n      if (theRightShip[0]) {\r\n        theRightShip[0].wasHit();\r\n        this.hits.push([x, y]);\r\n        if (theRightShip[0].wasSunk()) {\r\n          let marks = this.markAdjacent(\r\n            {\r\n              x: theRightShip[0].x,\r\n              y: theRightShip[0].y,\r\n            },\r\n            true\r\n          );\r\n          marks.forEach((mark) => {\r\n            if (\r\n              this.checkCoords(mark) &&\r\n              mark[0] >= 0 &&\r\n              mark[0] <= 9 &&\r\n              mark[1] >= 0 &&\r\n              mark[1] <= 9\r\n            ) {\r\n              this.visited.push(mark);\r\n            }\r\n          });\r\n          this.sunken.push(theRightShip[0]);\r\n        }\r\n        let marks = this.markAdjacent({ x: [x], y: [y] }, false);\r\n\r\n        marks.forEach((mark) => {\r\n          if (\r\n            this.checkCoords(mark) &&\r\n            mark[0] >= 0 &&\r\n            mark[0] <= 9 &&\r\n            mark[1] >= 0 &&\r\n            mark[1] <= 9\r\n          ) {\r\n            this.visited.push(mark);\r\n          }\r\n        });\r\n        return theRightShip[0];\r\n      }\r\n      return false;\r\n    },\r\n    reportLost() {\r\n      if (this.sunken.length !== 0) {\r\n        const lostShip = this.sunken[this.hits.sunken.length - 1];\r\n        return lostShip;\r\n      }\r\n      return false;\r\n    },\r\n    resetBoard() {\r\n      this.visited.length = 0;\r\n      this.occupied.length = 0;\r\n      this.sunken.length = 0;\r\n      this.attacks.length = 0;\r\n      this.hits.length = 0;\r\n    },\r\n  };\r\n};\r\n\r\nexport const Player = (type) => {\r\n  return {\r\n    type: type,\r\n    nextTarget: [],\r\n    hits: [],\r\n    possibleTargets(coords) {\r\n      let directions = [\r\n        { dx: -1, dy: 0 },\r\n        { dx: 1, dy: 0 },\r\n        { dx: 0, dy: -1 },\r\n        { dx: 0, dy: 1 },\r\n      ];\r\n      const mappedCoords = directions.map((direction) => ({\r\n        x: coords.x + direction.dx,\r\n        y: coords.y + direction.dy,\r\n      }));\r\n      const validCoords = mappedCoords.filter((obj) => {\r\n        return obj.x <= 9 && obj.x >= 0 && obj.y <= 9 && obj.y >= 0;\r\n      });\r\n\r\n      return validCoords;\r\n    },\r\n    excludeCells(coord, board) {\r\n      const dirs = [];\r\n      const map = (coord, board) => {\r\n        const temp = [];\r\n        temp.push({ x: coord.x + 1, y: coord.y });\r\n        temp.push({ x: coord.x, y: coord.y + 1 });\r\n        temp.push({ x: coord.x - 1, y: coord.y });\r\n        temp.push({ x: coord.x, y: coord.y - 1 });\r\n\r\n        const filtered = temp.filter((obj) => {\r\n          return obj.x <= 9 && obj.x >= 0 && obj.y <= 9 && obj.y >= 0;\r\n        });\r\n        const notVisited = filtered.filter((element) => {\r\n          return !board.visited.some(\r\n            (pair) => pair[0] === element.x && pair[1] === element.y\r\n          );\r\n        });\r\n        return notVisited;\r\n      };\r\n      const mapped = map(coord, board);\r\n\r\n      if (mapped.length == 0) {\r\n        dirs.push([coord.x, coord.y]);\r\n      } else {\r\n        mapped.forEach((item) => {\r\n          if (map(item, board).length >= 3) {\r\n            dirs.push([item.x, item.y]);\r\n          }\r\n        });\r\n      }\r\n\r\n      return dirs;\r\n    },\r\n    calcTargetCoords(board) {\r\n      const grid = board.createGrid();\r\n      const filteredCoords = grid.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element[0] && pair[1] === element[1]\r\n        );\r\n      });\r\n      const random = Math.floor(Math.random() * filteredCoords.length);\r\n      const coords = filteredCoords[random];\r\n      return { x: coords[0], y: coords[1] };\r\n    },\r\n    searchPattern(board) {\r\n      const tempX = [];\r\n      const tempY = [];\r\n      const arrayOfArrays = [];\r\n      const grid = board.createGrid();\r\n      const filteredCoords = grid.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element[0] && pair[1] === element[1]\r\n        );\r\n      });\r\n      const alive = board.occupied.filter((ship) => {\r\n        return ship.isSunk === false;\r\n      });\r\n      const biggest = alive.sort((a, b) => a.size - b.size)[0].size;\r\n\r\n      const coordsByY = [...filteredCoords].sort((a, b) => a[1] - b[1]);\r\n\r\n      function processArray(arr, tempArr, arrayOfArrays) {\r\n        for (let i = 0; i < arr.length; i++) {\r\n          const current = arr[i];\r\n          const previous = i > 0 ? arr[i - 1] : arr[i];\r\n          const next = i < arr.length - 1 ? arr[i + 1] : arr[i];\r\n\r\n          if (current[1] === previous[1] && current[0] === previous[0] + 1) {\r\n            tempArr.push([current[0], current[1]]);\r\n          }\r\n          if (\r\n            current[0] !== next[0] - 1 ||\r\n            (current[1] !== next[1] &&\r\n              current[1] === previous[1] &&\r\n              current[0] === previous[0] + 1)\r\n          ) {\r\n            arrayOfArrays.push([...tempArr]);\r\n            tempArr.length = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      processArray(coordsByY, tempY, arrayOfArrays);\r\n      processArray(filteredCoords, tempX, arrayOfArrays);\r\n\r\n      const biggerThanBiggest = arrayOfArrays.filter(\r\n        (array) => array.length >= biggest\r\n      );\r\n\r\n      const targetArrays = biggerThanBiggest.sort(\r\n        (a, b) => b.length - a.length\r\n      );\r\n      if (targetArrays.length !== 0) {\r\n        if (biggest <= 3) {\r\n          const random = Math.floor(Math.random() * targetArrays.length);\r\n          const targetCoords =\r\n            targetArrays[random][\r\n              Math.floor(targetArrays[random].length / 2 - 1)\r\n            ];\r\n          return { x: targetCoords[0], y: targetCoords[1] };\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    commitAttack(board, input = this.searchPattern(board)) {\r\n      //ATTACK\r\n      this.nextTarget = this.nextTarget.filter((element) => {\r\n        return !board.visited.some(\r\n          (pair) => pair[0] === element.x && pair[1] === element.y\r\n        );\r\n      });\r\n\r\n      let coords = input;\r\n\r\n      const excluded = this.excludeCells(coords, board);\r\n      const excludedAndVisited = [...board.visited, ...excluded];\r\n      while (\r\n        excludedAndVisited.some(\r\n          (pair) => pair[0] === coords.x && pair[1] === coords.y\r\n        )\r\n      ) {\r\n        coords = this.calcTargetCoords(board);\r\n      }\r\n\r\n      if (this.nextTarget.length !== 0) {\r\n        coords = this.nextTarget.splice(\r\n          Math.floor(Math.random() * this.nextTarget.length),\r\n          1\r\n        )[0];\r\n      }\r\n\r\n      const attack = board.IncomingAttack(coords.x, coords.y);\r\n      if (attack) {\r\n        const nextCoords = this.possibleTargets(coords);\r\n        nextCoords.forEach((coord) => this.nextTarget.push({ ...coord }));\r\n        this.hits.push(coords);\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    createFleet(board) {\r\n      const size = [4, 3, 3, 2, 2, 2];\r\n      while (board.occupied.length < 6) {\r\n        const coords = this.calcTargetCoords(board);\r\n        const axis = Math.random() < 0.5 ? false : true;\r\n        const place = board.placeShip(coords.x, coords.y, size[0], axis);\r\n        if (place) {\r\n          size.shift();\r\n        }\r\n      }\r\n    },\r\n    resetPlayer() {\r\n      this.nextTarget.length = 0;\r\n      this.hits.length = 0;\r\n    },\r\n  };\r\n};\r\n\r\nexport const Game = () => {\r\n  const computer = {\r\n    player: Player(\"Computer\"),\r\n    board: Board(),\r\n  };\r\n  const human = {\r\n    player: Player(\"Human\"),\r\n    board: Board(),\r\n  };\r\n\r\n  return {\r\n    current: human.player.type,\r\n    turns: 1,\r\n    over: false,\r\n    computer: computer,\r\n    human: human,\r\n    IsReady(array) {\r\n      if (array.length === 6) {\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    newGame(input) {\r\n      computer.player.createFleet(computer.board);\r\n      !input\r\n        ? human.player.createFleet(human.board)\r\n        : input.forEach((item) =>\r\n            human.board.placeShip(item.x[0], item.y[0], item.size, item.axis)\r\n          );\r\n    },\r\n    declareWinner() {\r\n      if (human.board.isOver()) {\r\n        this.over = true;\r\n        return computer.player.type;\r\n      } else if (computer.board.isOver()) {\r\n        this.over = true;\r\n        return human.player.type;\r\n      }\r\n      return false;\r\n    },\r\n    turn(input) {\r\n      if (!this.declareWinner()) {\r\n        if (this.current === \"Computer\") {\r\n          computer.player.commitAttack(human.board);\r\n          this.current = \"Human\";\r\n          this.turns++;\r\n          return true;\r\n        }\r\n        if (this.current === \"Human\") {\r\n          input\r\n            ? computer.board.IncomingAttack(input[0], input[1])\r\n            : human.player.commitAttack(computer.board);\r\n          this.current = \"Computer\";\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n    reportTurns() {\r\n      return this.turns;\r\n    },\r\n    reportCurrentPlayer() {\r\n      if (this.current === \"Human\") {\r\n        return this.current;\r\n      } else {\r\n        return this.current;\r\n      }\r\n    },\r\n    resetGame() {\r\n      this.current = human.player.type;\r\n      this.turns = 1;\r\n      this.over = false;\r\n      this.human.player.resetPlayer();\r\n      this.computer.player.resetPlayer();\r\n      this.human.board.resetBoard();\r\n      this.computer.board.resetBoard();\r\n    },\r\n  };\r\n};\r\n","import { Ship, Board, Player, Game } from \"./game.js\";\r\n\r\nexport const RenderGame = (game) => {\r\n  return {\r\n    eventListeners: [],\r\n    turnInProgress: false,\r\n    shipsToPlace: [],\r\n    shipsOnGrid: [],\r\n    selected: false,\r\n    clearEventListeners() {\r\n      while (this.eventListeners.length !== 0) {\r\n        const listener = this.eventListeners.pop();\r\n        listener.elem.removeEventListener(listener.type, listener.listener);\r\n      }\r\n    },\r\n    renderGrid(board) {\r\n      const grids = document.querySelectorAll(\".grid\");\r\n      const cells = board.createGrid();\r\n      grids.forEach((grid) => {\r\n        cells.forEach((cell) => {\r\n          const newCell = document.createElement(\"div\");\r\n          newCell.classList.add(\"cell\");\r\n          newCell.setAttribute(\"data-x\", cell[1]);\r\n          newCell.setAttribute(\"data-y\", cell[0]);\r\n          grid.appendChild(newCell);\r\n        });\r\n      });\r\n    },\r\n    populateGrid(draggedOffset, ev, board) {\r\n      const canBe = this.checkIfCanBePlaced(draggedOffset, ev, board);\r\n      if (canBe) {\r\n        this.shipsOnGrid.push(canBe);\r\n        return true;\r\n      } else {\r\n        this.placementTip();\r\n      }\r\n\r\n      return false;\r\n    },\r\n    clearGrids() {\r\n      const grids = document.querySelectorAll(\".grid\");\r\n      for (const grid of grids) {\r\n        while (grid.firstChild) {\r\n          grid.removeChild(grid.firstChild);\r\n        }\r\n      }\r\n    },\r\n    renderShips(array, grid) {\r\n      array.forEach((item) => {\r\n        const gridArray = Array.from(grid.children);\r\n        const cell = gridArray.find(\r\n          (child) =>\r\n            child.getAttribute(\"data-x\") == item.x[0] &&\r\n            child.getAttribute(\"data-y\") == item.y[0]\r\n        );\r\n        const ship = document.createElement(\"div\");\r\n        ship.classList.add(`ship${item.size}`, \"ship\");\r\n        ship.classList.add(`${item.axis ? \"horizontal\" : \"vertical\"}`);\r\n        if (item.isSunk == true) {\r\n          ship.classList.add(\"sunk\");\r\n        }\r\n        if (cell.children.length === 0) {\r\n          cell.appendChild(ship);\r\n        }\r\n      });\r\n    },\r\n    renderMiss(array, grid) {\r\n      array.forEach((item) => {\r\n        const gridArray = Array.from(grid.children);\r\n        const cell = gridArray.find(\r\n          (child) =>\r\n            child.getAttribute(\"data-x\") == item[0] &&\r\n            child.getAttribute(\"data-y\") == item[1]\r\n        );\r\n        cell.textContent = \"*\";\r\n      });\r\n    },\r\n    renderHit(array, grid) {\r\n      array.forEach((item) => {\r\n        const gridArray = Array.from(grid.children);\r\n        const cell = gridArray.find(\r\n          (child) =>\r\n            child.getAttribute(\"data-x\") == item[0] &&\r\n            child.getAttribute(\"data-y\") == item[1]\r\n        );\r\n        cell.style.backgroundColor = \"hsla(271, 76%, 53%, 0.274)\";\r\n        cell.style.border = \"3px solid hsla(271, 76%, 53%, 0.774)\";\r\n        cell.textContent = \"X\";\r\n      });\r\n    },\r\n    renderAttacks(array, grid) {\r\n      array.forEach((item) => {\r\n        const gridArray = Array.from(grid.children);\r\n        const cell = gridArray.find(\r\n          (child) =>\r\n            child.getAttribute(\"data-x\") == item[0] &&\r\n            child.getAttribute(\"data-y\") == item[1]\r\n        );\r\n        cell.style.backgroundColor = \"rgba(0, 0, 0, 0.356)\";\r\n        cell.textContent = \"+\";\r\n        if (item == array[array.length - 1]) {\r\n          cell.style.color = \"red\";\r\n        }\r\n      });\r\n    },\r\n    flipShip() {\r\n      const ships = this.shipsToPlace;\r\n\r\n      const flipHandler = (ev) => {\r\n        if (this.isTouchDevice() && !this.selected) {\r\n          this.selected = true;\r\n          return;\r\n        }\r\n\r\n        if (this.isTouchDevice() && this.selected) {\r\n          if (ev.target.style.transform == \"rotate(90deg)\") {\r\n            ev.target.setAttribute(\"data-axis\", \"true\");\r\n            ev.target.style.transform = \"none\";\r\n          } else {\r\n            ev.target.setAttribute(\"data-axis\", \"false\");\r\n            ev.target.style.transform = \"rotate(90deg)\";\r\n          }\r\n        } else if (!this.isTouchDevice()) {\r\n          if (ev.target.style.transform == \"rotate(90deg)\") {\r\n            ev.target.setAttribute(\"data-axis\", \"true\");\r\n            ev.target.style.transform = \"none\";\r\n          } else {\r\n            ev.target.setAttribute(\"data-axis\", \"false\");\r\n            ev.target.style.transform = \"rotate(90deg)\";\r\n          }\r\n        }\r\n      };\r\n      ships.forEach((ship) => {\r\n        ship.addEventListener(\"click\", flipHandler);\r\n        this.eventListeners.push({\r\n          elem: ship,\r\n          type: \"click\",\r\n          listener: flipHandler,\r\n        });\r\n      });\r\n    },\r\n    createShipsToPlace() {\r\n      const sizes = [4, 3, 3, 2, 2, 2];\r\n      while (this.shipsToPlace.length < 6) {\r\n        const ship = document.createElement(\"div\");\r\n        const size = sizes.shift();\r\n        ship.setAttribute(\"data-size\", size);\r\n        ship.setAttribute(\"data-axis\", true);\r\n        ship.classList.add(\"shipCreate\", `ship${size}`);\r\n        ship.setAttribute(\"draggable\", true);\r\n        this.shipsToPlace.push(ship);\r\n      }\r\n    },\r\n    giveShipToPlace(isTrue) {\r\n      const container = document.querySelector(\r\n        \".fleetCreationScreen .shipsContainer\"\r\n      );\r\n      const count = document.querySelector(\r\n        \".fleetCreationScreen .shipContainerCount\"\r\n      );\r\n      if (this.isTouchDevice()) {\r\n        count.textContent = `Touch to select, touch again to rotate, touch grid cell to place, remaining: ${this.shipsToPlace.length}`;\r\n        count.style.fontSize = \"1.3rem\";\r\n      } else {\r\n        count.textContent = `Click to rotate, drag to place, remaining: ${this.shipsToPlace.length}`;\r\n      }\r\n\r\n      container.appendChild(this.shipsToPlace[0]);\r\n      if (isTrue) {\r\n        container.removeChild(container.firstChild);\r\n        this.shipsToPlace.shift();\r\n        count.textContent = this.shipsToPlace.length;\r\n        if (this.shipsToPlace.length !== 0) {\r\n          container.appendChild(this.shipsToPlace[0]);\r\n        }\r\n      }\r\n    },\r\n    checkIfCanBePlaced(draggedOffset, ev, board) {\r\n      //calculates first cell of the ship and check if its a valid spot\r\n      const axis = draggedOffset.axis;\r\n\r\n      const offsetX = axis\r\n        ? +ev.target.getAttribute(\"data-x\") - draggedOffset.offset + 1\r\n        : +ev.target.getAttribute(\"data-x\");\r\n      const offsetY = axis\r\n        ? +ev.target.getAttribute(\"data-y\")\r\n        : +ev.target.getAttribute(\"data-y\") - draggedOffset.offset + 1;\r\n      const canBe = board.canBePlaced(\r\n        offsetX,\r\n        offsetY,\r\n        draggedOffset.size,\r\n        axis,\r\n        this.shipsOnGrid\r\n      );\r\n\r\n      if (canBe.can) {\r\n        return {\r\n          x: canBe[0].cx,\r\n          y: canBe[0].cy,\r\n          size: draggedOffset.size,\r\n          axis: axis,\r\n        };\r\n      }\r\n      return false;\r\n    },\r\n\r\n    highlightCells(draggedOffset, ev, board) {\r\n      const canBe = this.checkIfCanBePlaced(draggedOffset, ev, board);\r\n      const cells = [];\r\n      const x = +ev.target.getAttribute(\"data-x\");\r\n      const y = +ev.target.getAttribute(\"data-y\");\r\n      const offsetBehind = draggedOffset.size - draggedOffset.offset;\r\n      const axis = draggedOffset.axis;\r\n      cells.push(ev.target);\r\n\r\n      const addCellIfValid = (cells, x, y) => {\r\n        const cell = document.querySelector(`[data-x='${x}'][data-y='${y}']`);\r\n        if (cell) {\r\n          cells.push(cell);\r\n        }\r\n      };\r\n      for (let i = 0; i <= draggedOffset.offset - 1; i++) {\r\n        if (axis) {\r\n          addCellIfValid(cells, x - i, y);\r\n        } else {\r\n          addCellIfValid(cells, x, y - i);\r\n        }\r\n      }\r\n      for (let i = 0; i <= offsetBehind; i++) {\r\n        if (axis) {\r\n          addCellIfValid(cells, x + i, y);\r\n        } else {\r\n          addCellIfValid(cells, x, y + i);\r\n        }\r\n      }\r\n\r\n      if (canBe) {\r\n        cells.forEach((cell) => {\r\n          if (cell.classList.contains(\"cellCan\")) {\r\n            cell.classList.remove(\"cellCan\");\r\n          } else {\r\n            cell.classList.add(\"cellCan\");\r\n          }\r\n        });\r\n      } else {\r\n        cells.forEach((cell) => {\r\n          if (cell.classList.contains(\"cellCannot\")) {\r\n            cell.classList.remove(\"cellCannot\");\r\n          } else {\r\n            cell.classList.add(\"cellCannot\");\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    dragElement() {\r\n      const board = game.human.board;\r\n      const ships = this.shipsToPlace;\r\n      const grid = document.querySelector(\".fleetCreationScreen .grid\");\r\n      let draggedOffset;\r\n\r\n      const dragStartEvHandler = (ship, ev) => {\r\n        draggedOffset = calculateOffset(ship, ev);\r\n        if (draggedOffset.axis == false) {\r\n          this.rotateDraggedGhostImg(ev);\r\n        }\r\n      };\r\n\r\n      const dropEventHandler = (ev) => {\r\n        ev.preventDefault();\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n          const pushShip = this.populateGrid(draggedOffset, ev, board);\r\n          const grid = document.querySelector(\".grid\");\r\n          this.renderShips(this.shipsOnGrid, grid);\r\n          this.giveShipToPlace(pushShip);\r\n          if (game.IsReady(this.shipsOnGrid)) {\r\n            game.newGame(this.shipsOnGrid);\r\n            setTimeout(() => {\r\n              this.changeScreen();\r\n            }, 1000);\r\n          }\r\n        }\r\n      };\r\n\r\n      const dragOverHandler = (ev) => {\r\n        ev.preventDefault();\r\n      };\r\n\r\n      const dragEnterHandler = (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n        }\r\n      };\r\n\r\n      const dragLeaveHandler = (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          this.highlightCells(draggedOffset, ev, board);\r\n        }\r\n      };\r\n\r\n      ships.forEach((ship) => {\r\n        ship.addEventListener(\"dragstart\", (ev) =>\r\n          dragStartEvHandler(ship, ev)\r\n        );\r\n        this.eventListeners.push({\r\n          elem: ship,\r\n          type: \"dragstart\",\r\n          listener: dragStartEvHandler,\r\n        });\r\n      });\r\n\r\n      grid.addEventListener(\"dragover\", dragOverHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"dragover\",\r\n        listener: dragOverHandler,\r\n      });\r\n\r\n      grid.addEventListener(\"dragenter\", dragEnterHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"dragenter\",\r\n        listener: dragEnterHandler,\r\n      });\r\n\r\n      grid.addEventListener(\"dragleave\", dragLeaveHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"dragleave\",\r\n        listener: dragLeaveHandler,\r\n      });\r\n\r\n      grid.addEventListener(\"drop\", dropEventHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"drop\",\r\n        listener: dropEventHandler,\r\n      });\r\n\r\n      const calculateOffset = (element, ev) => {\r\n        const rectEl = element.getBoundingClientRect();\r\n        const axis = element.getAttribute(\"data-axis\") == \"true\" ? true : false;\r\n        const cursor = axis ? ev.clientX : ev.clientY;\r\n        let startingPoint = axis ? rectEl.x : rectEl.y;\r\n        const singleCell = axis\r\n          ? rectEl.width / element.getAttribute(\"data-size\")\r\n          : rectEl.height / element.getAttribute(\"data-size\");\r\n        let i = 1;\r\n        while (startingPoint + singleCell < cursor) {\r\n          startingPoint += singleCell;\r\n          i++;\r\n        }\r\n        return {\r\n          offset: i,\r\n          size: +element.getAttribute(\"data-size\"),\r\n          axis: axis,\r\n        };\r\n      };\r\n    },\r\n    touchPlacement() {\r\n      const board = game.human.board;\r\n      const ships = this.shipsToPlace;\r\n      const grid = document.querySelector(\".fleetCreationScreen .grid\");\r\n      let selected;\r\n\r\n      const selectEvHandler = (ev) => {\r\n        ev.target.classList.add(\"selected\");\r\n        const axis =\r\n          ev.target.getAttribute(\"data-axis\") == \"true\" ? true : false;\r\n        const size = +ev.target.getAttribute(\"data-size\");\r\n        selected = { offset: 1, axis: axis, size: size };\r\n      };\r\n\r\n      const dropEvHandler = (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          if (selected) {\r\n            const pushShip = this.populateGrid(selected, ev, board);\r\n            const grid = document.querySelector(\".grid\");\r\n            this.renderShips(this.shipsOnGrid, grid);\r\n            this.giveShipToPlace(pushShip);\r\n            if (pushShip) {\r\n              selected = \"\";\r\n              this.selected = false;\r\n            }\r\n          }\r\n          if (game.IsReady(this.shipsOnGrid)) {\r\n            game.newGame(this.shipsOnGrid);\r\n            setTimeout(() => {\r\n              this.changeScreen();\r\n            }, 1000);\r\n          }\r\n        }\r\n      };\r\n\r\n      ships.forEach((ship) => {\r\n        ship.addEventListener(\"click\", selectEvHandler);\r\n        this.eventListeners.push({\r\n          elem: ship,\r\n          type: \"click\",\r\n          listener: selectEvHandler,\r\n        });\r\n      });\r\n\r\n      grid.addEventListener(\"click\", dropEvHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"click\",\r\n        listener: dropEvHandler,\r\n      });\r\n    },\r\n\r\n    rotateDraggedGhostImg(ev) {\r\n      const ghost = document.createElement(\"div\");\r\n      if (ev.target.children.length !== 0) {\r\n        ev.target.removeChild(ev.target.firstChild);\r\n      }\r\n      ghost.style.position = \"absolute\";\r\n      ghost.style.transform = \"rotate(90deg)\";\r\n      ghost.style.pointerEvents = \"none\";\r\n\r\n      const inner = ev.target.cloneNode(true);\r\n      inner.style.pointerEvents = \"none\";\r\n      ghost.appendChild(inner);\r\n\r\n      const rect = ev.target.getBoundingClientRect();\r\n      const x = ev.clientX - rect.left + rect.height / 2.8;\r\n      const y = ev.clientY - rect.top;\r\n\r\n      ev.target.appendChild(ghost);\r\n      ev.dataTransfer.setDragImage(ghost, x, y);\r\n    },\r\n    changeScreen() {\r\n      const startScreen = document.querySelector(\".fleetCreationScreen\");\r\n      const gameScreen = document.querySelector(\".gamePlayScreen\");\r\n      const overScreen = document.querySelector(\".gameOverScreen\");\r\n      if (!game.IsReady(game.human.board.occupied)) {\r\n        startScreen.style.display = \"block\";\r\n        overScreen.classList.remove(\"slideDown\");\r\n        setTimeout(() => {\r\n          overScreen.style.display = \"none\";\r\n          startScreen.classList.remove(\"slideUp\");\r\n        }, 1300);\r\n        this.renderGridContent(false);\r\n      } else if (\r\n        game.IsReady(game.human.board.occupied) &&\r\n        !game.declareWinner()\r\n      ) {\r\n        startScreen.classList.add(\"slideUp\");\r\n        gameScreen.style.display = \"block\";\r\n        setTimeout(() => {\r\n          gameScreen.classList.add(\"slideFromBeneath\");\r\n          startScreen.style.display = \"none\";\r\n        }, 1300);\r\n        this.renderGridContent(false);\r\n      } else if (game.declareWinner()) {\r\n        gameScreen.classList.remove(\"slideFromBeneath\");\r\n        overScreen.style.display = \"block\";\r\n        setTimeout(() => {\r\n          gameScreen.style.display = \"none\";\r\n          overScreen.classList.add(\"slideDown\");\r\n        }, 1300);\r\n        this.renderGridContent(true);\r\n      }\r\n    },\r\n    renderGridContent(bool) {\r\n      const over = bool ? \"Over\" : \"\";\r\n      const playerGrid = document.querySelector(`.playerGrid${over}`);\r\n      const computerGrid = document.querySelector(`.computerGrid${over}`);\r\n      const playerBoard = game.human.board;\r\n      const computerBoard = game.computer.board;\r\n      const computerArray = bool\r\n        ? computerBoard.occupied\r\n        : computerBoard.sunken;\r\n      this.clearGrids();\r\n      this.renderGrid(playerBoard);\r\n      this.renderMiss(playerBoard.visited, playerGrid);\r\n      this.renderMiss(computerBoard.visited, computerGrid);\r\n      this.renderAttacks(computerBoard.attacks, computerGrid);\r\n      this.renderAttacks(playerBoard.attacks, playerGrid);\r\n      this.renderHit(playerBoard.hits, playerGrid);\r\n      this.renderHit(computerBoard.hits, computerGrid);\r\n      this.renderShips(playerBoard.occupied, playerGrid);\r\n      this.renderShips(computerArray, computerGrid);\r\n      this.announceTurn(bool);\r\n      this.announceScore(bool);\r\n    },\r\n    gridGameListeners() {\r\n      const board = game.computer.board;\r\n      const grid = document.querySelector(\".computerGrid\");\r\n\r\n      const gridClickHandler = (ev) => {\r\n        if (ev.target.classList.contains(\"cell\")) {\r\n          const cell = [\r\n            +ev.target.getAttribute(\"data-x\"),\r\n            +ev.target.getAttribute(\"data-y\"),\r\n          ];\r\n          if (board.checkCoords(cell) && !this.turnInProgress) {\r\n            game.turn(cell);\r\n\r\n            this.renderGridContent(false);\r\n            this.turnInProgress = true;\r\n            setTimeout(() => {\r\n              if (game.declareWinner()) {\r\n                this.gameOver();\r\n                return;\r\n              }\r\n              this.alternateGrids();\r\n            }, 900);\r\n\r\n            setTimeout(() => {\r\n              game.turn();\r\n\r\n              this.renderGridContent(false);\r\n              setTimeout(() => {\r\n                if (game.declareWinner()) {\r\n                  this.gameOver();\r\n                  return;\r\n                }\r\n                this.turnInProgress = false;\r\n                this.alternateGrids();\r\n              }, 1500);\r\n            }, 2100);\r\n          }\r\n        }\r\n      };\r\n      grid.addEventListener(\"click\", gridClickHandler);\r\n      this.eventListeners.push({\r\n        elem: grid,\r\n        type: \"click\",\r\n        listener: gridClickHandler,\r\n      });\r\n    },\r\n    announceTurn(bool) {\r\n      const over = bool ? \"Over\" : \"\";\r\n      const turnOutlet = document.querySelector(`.turnAnnouncement${over}`);\r\n      turnOutlet.textContent = `Turn: ${game.turns}`;\r\n    },\r\n    announceScore(bool) {\r\n      const over = bool ? \"Over\" : \"\";\r\n      const computerScoreOutlet = document.querySelector(\r\n        `.playerSunken${over}`\r\n      );\r\n      const playerScoreOutlet = document.querySelector(\r\n        `.computerSunken${over}`\r\n      );\r\n\r\n      computerScoreOutlet.textContent = `${game.human.board.sunken.length} / ${game.human.board.occupied.length}`;\r\n      playerScoreOutlet.textContent = `${game.computer.board.sunken.length} / ${game.computer.board.occupied.length}`;\r\n    },\r\n    alternateGrids() {\r\n      const playerBoard = document.querySelector(\".playerBoard\");\r\n      const computerBoard = document.querySelector(\".computerBoard\");\r\n\r\n      if (playerBoard.classList.contains(\"highlight\")) {\r\n        playerBoard.classList.remove(\"highlight\");\r\n        computerBoard.parentElement.classList.remove(\"slideFromMid\");\r\n        playerBoard.parentElement.classList.remove(\"slideToMid\");\r\n        computerBoard.classList.add(\"highlight\");\r\n        return;\r\n      }\r\n      if (computerBoard.classList.contains(\"highlight\")) {\r\n        computerBoard.classList.remove(\"highlight\");\r\n        playerBoard.classList.add(\"highlight\");\r\n        computerBoard.parentElement.classList.add(\"slideFromMid\");\r\n        playerBoard.parentElement.classList.add(\"slideToMid\");\r\n        return;\r\n      }\r\n    },\r\n    gameOver() {\r\n      const winner = game.declareWinner();\r\n      const winnerAnnouncement = document.querySelector(\".winner\");\r\n      this.changeScreen();\r\n      if (winner == \"Human\") {\r\n        winnerAnnouncement.textContent = \"Victory!\";\r\n      } else {\r\n        winnerAnnouncement.textContent = \"Defeat.\";\r\n      }\r\n    },\r\n    restartGameListener() {\r\n      const restart = document.querySelector(\".restartBtn\");\r\n\r\n      const restartEvHandler = () => {\r\n        this.clearEventListeners();\r\n        game.resetGame();\r\n        this.turnInProgress = false;\r\n        this.shipsToPlace.length = 0;\r\n        this.shipsOnGrid.length = 0;\r\n        this.changeScreen();\r\n        this.createShipsToPlace();\r\n        this.flipShip();\r\n        if (this.isTouchDevice()) {\r\n          this.touchPlacement();\r\n        } else {\r\n          this.dragElement();\r\n        }\r\n        this.giveShipToPlace();\r\n\r\n        this.gridGameListeners();\r\n        this.restartGameListener();\r\n      };\r\n\r\n      restart.addEventListener(\"click\", restartEvHandler);\r\n      this.eventListeners.push({\r\n        elem: restart,\r\n        type: \"click\",\r\n        listener: restartEvHandler,\r\n      });\r\n    },\r\n    initGame() {\r\n      this.changeScreen();\r\n      this.createShipsToPlace();\r\n      this.flipShip();\r\n      if (this.isTouchDevice()) {\r\n        this.touchPlacement();\r\n      } else {\r\n        this.dragElement();\r\n      }\r\n      this.giveShipToPlace();\r\n\r\n      this.gridGameListeners();\r\n      this.restartGameListener();\r\n    },\r\n    isTouchDevice() {\r\n      if (\"ontouchstart\" in window || navigator.maxTouchPoints) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n    placementTip() {\r\n      const textOutput = document.querySelector(\".textOutput\");\r\n\r\n      textOutput.textContent = \"Too close to the edge or other ships\";\r\n    },\r\n  };\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Ship, Board, Player, Game } from \"./game.js\";\r\nimport { RenderGame } from \"./render.js\";\r\n\r\nconst game = Game();\r\nconst renderGame = RenderGame(game);\r\nrenderGame.initGame();\r\n"],"names":[],"sourceRoot":""}